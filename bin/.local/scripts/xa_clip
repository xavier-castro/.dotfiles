#!/bin/bash

# Norg Note Creator - Create .norg files from clipboard content
# Features: Multi-platform clipboard support, TUI interface, AI summarization, tag management

set -euo pipefail

# Configuration
SCRIPT_NAME="Norg Note Creator"
VERSION="1.0.0"
DEFAULT_OUTPUT_DIR="$HOME/personal/clips"
CONFIG_FILE="$HOME/.config/norg-creator.conf"

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Global variables
CLIPBOARD_TOOL=""
TUI_TOOL=""
OPENAI_API_KEY=""
OUTPUT_DIR="$DEFAULT_OUTPUT_DIR"

# Load configuration
load_config() {
    if [[ -f "$CONFIG_FILE" ]]; then
        source "$CONFIG_FILE"
    fi
}

# Save configuration
save_config() {
    mkdir -p "$(dirname "$CONFIG_FILE")"
    cat > "$CONFIG_FILE" << EOF
# Norg Creator Configuration
OUTPUT_DIR="$OUTPUT_DIR"
OPENAI_API_KEY="$OPENAI_API_KEY"
EOF
}

# Logging functions
log_info() {
    echo -e "${BLUE}[INFO]${NC} $1" >&2
}

log_success() {
    echo -e "${GREEN}[SUCCESS]${NC} $1" >&2
}

log_warning() {
    echo -e "${YELLOW}[WARNING]${NC} $1" >&2
}

log_error() {
    echo -e "${RED}[ERROR]${NC} $1" >&2
}

# Detect available clipboard tools
detect_clipboard_tool() {
    # Prefer native tools first
    if [[ "$OSTYPE" == "darwin"* ]] && command -v pbcopy >/dev/null 2>&1 && command -v pbpaste >/dev/null 2>&1; then
        CLIPBOARD_TOOL="pbcopy"
    elif command -v wl-copy >/dev/null 2>&1 && command -v wl-paste >/dev/null 2>&1; then
        CLIPBOARD_TOOL="wl-clipboard"
    elif command -v xclip >/dev/null 2>&1; then
        CLIPBOARD_TOOL="xclip"
    elif command -v pbcopy >/dev/null 2>&1 && command -v pbpaste >/dev/null 2>&1; then
        CLIPBOARD_TOOL="pbcopy"
    elif command -v clip.exe >/dev/null 2>&1; then
        CLIPBOARD_TOOL="clip"
    else
        log_error "No supported clipboard tool found. Please install one of: wl-clipboard, xclip, pbcopy, or clip"
        exit 1
    fi
    log_info "Using clipboard tool: $CLIPBOARD_TOOL"
}

# Detect available TUI tools
detect_tui_tool() {
    if command -v gum >/dev/null 2>&1; then
        TUI_TOOL="gum"
    elif command -v whiptail >/dev/null 2>&1; then
        TUI_TOOL="whiptail"
    elif command -v dialog >/dev/null 2>&1; then
        TUI_TOOL="dialog"
    else
        log_error "No supported TUI tool found. Please install gum, whiptail, or dialog"
        exit 1
    fi
    log_info "Using TUI tool: $TUI_TOOL"
}

# Get clipboard content
get_clipboard_content() {
    local content=""
    case "$CLIPBOARD_TOOL" in
        "wl-clipboard")
            content=$(wl-paste 2>/dev/null || echo "")
            ;;
        "xclip")
            content=$(xclip -selection clipboard -o 2>/dev/null || echo "")
            ;;
        "pbcopy")
            content=$(pbpaste 2>/dev/null || echo "")
            ;;
        "clip")
            content=$(powershell.exe -command "Get-Clipboard" 2>/dev/null | tr -d '\r' || echo "")
            ;;
    esac
    echo "$content"
}

# Show TUI dialog
show_dialog() {
    local dialog_type="$1"
    local title="$2"
    local text="$3"
    local height="${4:-10}"
    local width="${5:-60}"
    shift 5

    case "$TUI_TOOL" in
        "gum")
            case "$dialog_type" in
                "msgbox")
                    gum style --foreground 212 --border-foreground 212 --border double --align center --width 50 --margin "1 2" --padding "2 4" "$title" "$text"
                    gum input --placeholder "Press Enter to continue..."
                    ;;
                "inputbox")
                    local default_value="$1"
                    echo "$text"
                    gum input --placeholder "Enter value..." --value "$default_value"
                    ;;
                "textbox")
                    gum pager < "$text"
                    ;;
                "menu")
                    echo "$text"
                    local options=()
                    while [[ $# -gt 0 ]]; do
                        options+=("$2")  # Skip the key, use the description
                        shift 2
                    done
                    gum choose "${options[@]}"
                    ;;
                "yesno")
                    echo "$text"
                    gum confirm
                    ;;
            esac
            ;;
        "whiptail")
            case "$dialog_type" in
                "msgbox")
                    whiptail --title "$title" --msgbox "$text" $height $width
                    ;;
                "inputbox")
                    whiptail --title "$title" --inputbox "$text" $height $width "$@" 3>&1 1>&2 2>&3
                    ;;
                "textbox")
                    whiptail --title "$title" --textbox "$text" $height $width
                    ;;
                "menu")
                    whiptail --title "$title" --menu "$text" $height $width $((height-8)) "$@" 3>&1 1>&2 2>&3
                    ;;
                "yesno")
                    whiptail --title "$title" --yesno "$text" $height $width
                    ;;
            esac
            ;;
        "dialog")
            case "$dialog_type" in
                "msgbox")
                    dialog --title "$title" --msgbox "$text" $height $width
                    ;;
                "inputbox")
                    dialog --title "$title" --inputbox "$text" $height $width "$@" 3>&1 1>&2 2>&3
                    ;;
                "textbox")
                    dialog --title "$title" --textbox "$text" $height $width
                    ;;
                "menu")
                    dialog --title "$title" --menu "$text" $height $width $((height-8)) "$@" 3>&1 1>&2 2>&3
                    ;;
                "yesno")
                    dialog --title "$title" --yesno "$text" $height $width
                    ;;
            esac
            ;;
    esac
}

# Extract title from URL
extract_url_title() {
    local url="$1"
    local title=""

    # Try to fetch the title using curl with timeout
    if command -v curl >/dev/null 2>&1; then
        title=$(timeout 10 curl -s -L "$url" 2>/dev/null | grep -i '<title>' | sed 's/<[^>]*>//g' | head -1 | xargs 2>/dev/null || echo "")
    fi

    # Fallback: use clean domain name
    if [[ -z "$title" ]]; then
        # Extract domain and clean it up
        title=$(echo "$url" | sed 's|https\?://||' | sed 's|/.*||' | sed 's|www\.||' | cut -d'.' -f1)
        # Simple cleanup - just capitalize first letter
        title=$(echo "$title" | sed 's/^./\U&/')
    fi

    echo "$title"
}

# Generate AI summary using OpenAI API
generate_ai_summary() {
    local content="$1"
    local max_length="${2:-150}"

    if [[ -z "$OPENAI_API_KEY" ]]; then
        log_warning "OpenAI API key not configured"
        return 1
    fi

    if ! command -v curl >/dev/null 2>&1; then
        log_error "curl is required for AI summarization"
        return 1
    fi

    local prompt="Summarize the following content in $max_length words or less. Focus on the main points and key information:\n\n$content"

    local response=$(curl -s -X POST "https://api.openai.com/v1/chat/completions" \
            -H "Content-Type: application/json" \
            -H "Authorization: Bearer $OPENAI_API_KEY" \
            -d "{
            \"model\": \"gpt-3.5-turbo\",
            \"messages\": [
                {\"role\": \"user\", \"content\": \"$prompt\"}
            ],
            \"max_tokens\": 200,
            \"temperature\": 0.7
    }" 2>/dev/null)

    if [[ $? -eq 0 ]] && echo "$response" | grep -q "choices"; then
        echo "$response" | grep -o '"content":"[^"]*"' | sed 's/"content":"//;s/"$//' | sed 's/\\n/\n/g'
    else
        log_error "Failed to generate AI summary"
        return 1
    fi
}

# Check if content is a URL
is_url() {
    local content="$1"
    [[ "$content" =~ ^https?:// ]]
}

# Check if content appears to be HTML/web content
is_html_content() {
    local content="$1"
    # Check for common HTML tags or patterns
    if echo "$content" | grep -q -i -E '<(html|head|body|title|div|p|span|script|style)'; then
        return 0
    fi
    # Check for HTML entities
    if echo "$content" | grep -q -E '&[a-zA-Z]+;|&#[0-9]+;'; then
        return 0
    fi
    # Check for DOCTYPE
    if echo "$content" | grep -q -i '<!DOCTYPE'; then
        return 0
    fi
    return 1
}

# Extract title from HTML content
extract_html_title() {
    local content="$1"
    local title=""

    # Try to extract HTML title tag
    title=$(echo "$content" | grep -i '<title>' | sed 's/<[^>]*>//g' | head -1 | xargs 2>/dev/null || echo "")

    # If no title tag, try H1 tags
    if [[ -z "$title" ]]; then
        title=$(echo "$content" | grep -i '<h1>' | sed 's/<[^>]*>//g' | head -1 | xargs 2>/dev/null || echo "")
    fi

    # Clean up and limit length
    title=$(echo "$title" | sed 's/[^a-zA-Z0-9[:space:]._-]//g' | cut -c1-40 | xargs)

    echo "$title"
}

# Sanitize filename
sanitize_filename() {
    local filename="$1"
    # Remove invalid characters and truncate to 100 characters
    echo "$filename" | sed 's/[^a-zA-Z0-9._-]/_/g' | sed 's/__*/_/g' | sed 's/^_//;s/_$//' | cut -c1-100
}
# Create .norg file
create_norg_file() {
    local title="$1"
    local content="$2"
    local summary="$3"
    local tags="$4"
    local original_url="$5"

    local date=$(date +"%Y-%m-%d")
    local datetime=$(date +"%Y-%m-%d %H:%M:%S")
    local safe_title=$(sanitize_filename "$title")
    local filename="${date}_${safe_title}.norg"
    local filepath="$OUTPUT_DIR/$filename"

    # Ensure output directory exists
    mkdir -p "$OUTPUT_DIR"

    # Create the .norg file
    cat > "$filepath" << EOF
@document.meta
title: $title
description: $summary
created: $datetime
categories: [
    notes
]
version: 1.0
EOF

    # Add tags if provided
    if [[ -n "$tags" ]]; then
        echo "tags: [" >> "$filepath"
        IFS=',' read -ra TAG_ARRAY <<< "$tags"
        for tag in "${TAG_ARRAY[@]}"; do
            tag=$(echo "$tag" | xargs) # trim whitespace
            echo "    $tag" >> "$filepath"
        done
        echo "]" >> "$filepath"
    fi

    echo "@end" >> "$filepath"
    echo "" >> "$filepath"
    echo "* $title" >> "$filepath"
    echo "" >> "$filepath"

    if [[ -n "$original_url" ]]; then
        echo "** Source" >> "$filepath"
        echo "   {Original Link}[$original_url]" >> "$filepath"
        echo "" >> "$filepath"
    fi

    echo "** Summary" >> "$filepath"
    echo "   $summary" >> "$filepath"
    echo "" >> "$filepath"

    if [[ -n "$content" ]] && [[ "$content" != "$original_url" ]]; then
        echo "** Content" >> "$filepath"
        echo "" >> "$filepath"
        # Add content with proper indentation for norg format
        echo "$content" | sed 's/^/   /' >> "$filepath"
    fi

    echo "$filepath"
}

# Main workflow
main() {
    log_info "Starting $SCRIPT_NAME v$VERSION"

    # Load configuration
    load_config

    # Detect required tools
    detect_clipboard_tool
    detect_tui_tool

    # Get clipboard content
    local clipboard_content=$(get_clipboard_content)

    if [[ -z "$clipboard_content" ]]; then
        show_dialog "msgbox" "Error" "Clipboard is empty or could not be read."
        exit 1
    fi

    log_info "Retrieved clipboard content (${#clipboard_content} characters)"

    # Determine if content is URL
    local is_url_content=false
    local original_url=""
    local title=""

    if is_url "$clipboard_content"; then
        is_url_content=true
        original_url="$clipboard_content"
        log_info "Detected URL in clipboard"

        # Extract title from URL
        title=$(extract_url_title "$original_url")
        if [[ -z "$title" ]]; then
            title="Untitled Link"
        fi
    else
        # For non-URL content, determine if it's HTML and extract title accordingly
        if is_html_content "$clipboard_content"; then
            log_info "Detected HTML content in clipboard"
            title=$(extract_html_title "$clipboard_content")

            if [[ -z "$title" ]] || [[ ${#title} -lt 3 ]]; then
                title="Web Content $(date +%H:%M)"
            fi
        else
            # For plain text content, create a simple title
            # Try to extract first meaningful words, avoiding markdown junk
            local first_line=$(echo "$clipboard_content" | head -1 | sed 's/^[[:space:]]*//' | sed 's/[{}()\[\]#*_`]//g')

            # Take first few words only, max 40 characters
            title=$(echo "$first_line" | cut -d' ' -f1-6 | cut -c1-40 | sed 's/[^a-zA-Z0-9[:space:]._-]//g' | xargs)

            # If still empty or too short, use generic title
            if [[ -z "$title" ]] || [[ ${#title} -lt 3 ]]; then
                title="Note $(date +%H:%M)"
            fi
        fi
    fi

    # Allow user to edit title (only in interactive terminal)
    if [[ -t 0 && -t 1 && -z "${CI:-}" ]]; then
        echo "Current title: $title"
        echo "Enter or edit the title for this note (press Enter to keep current):"
        if [[ "$TUI_TOOL" == "gum" ]]; then
            new_title=$(gum input --value "$title" --width 60 --placeholder "Edit the title..." || true)
            if [[ -n "$new_title" ]] && [[ "$new_title" != "$title" ]]; then
                title="$new_title"
            elif [[ -z "$new_title" ]]; then
                # If gum input was cancelled or failed, keep original title
                log_info "Keeping original title: $title"
            fi
        else
            new_title=$(show_dialog "inputbox" "Note Title" "Enter or edit the title for this note:" 10 60 "$title" || echo "")
            if [[ -n "$new_title" ]]; then
                title="$new_title"
            fi
        fi
    fi

    if [[ -z "$title" ]]; then
        log_error "Title is required"
        exit 1
    fi

    # Summary generation options
    local summary=""
    local summary_choice

    # Summary generation options
    local summary=""
    local summary_choice=""

    if [[ -t 0 && -t 1 ]]; then
        if [[ "$TUI_TOOL" == "gum" ]]; then
            if [[ -n "$OPENAI_API_KEY" ]]; then
                echo "Choose how to create the summary:"
                summary_choice=$(gum choose "Generate AI summary" "Enter manual summary" "Skip summary" || echo "Skip summary")
            else
                echo "Choose how to create the summary:"
                summary_choice=$(gum choose "Enter manual summary" "Skip summary" || echo "Skip summary")
            fi
        else
            if [[ -n "$OPENAI_API_KEY" ]]; then
                summary_choice=$(show_dialog "menu" "Summary Generation" "Choose how to create the summary:" 15 60 \
                        "1" "Generate AI summary" \
                        "2" "Enter manual summary" \
                    "3" "Skip summary" || echo "3")
            else
                summary_choice=$(show_dialog "menu" "Summary Generation" "Choose how to create the summary:" 12 60 \
                        "2" "Enter manual summary" \
                    "3" "Skip summary" || echo "3")
            fi
        fi
    else
        summary_choice="Skip summary"
    fi

    case "$summary_choice" in
        "Generate AI summary"|"1")
            if [[ -n "$OPENAI_API_KEY" ]]; then
                log_info "Generating AI summary..."
                if [[ "$TUI_TOOL" == "gum" ]]; then
                    gum spin --spinner dot --title "Generating AI summary..." -- sleep 1 &
                    local spin_pid=$!
                fi
                summary=$(generate_ai_summary "$clipboard_content")
                if [[ "$TUI_TOOL" == "gum" ]] && kill $spin_pid 2>/dev/null; then
                    wait $spin_pid 2>/dev/null
                fi
                if [[ $? -ne 0 ]] || [[ -z "$summary" ]]; then
                    log_warning "Failed to generate AI summary. Please try manual entry."
                    if [[ -t 0 && -t 1 ]]; then
                        echo "Enter a summary for this note:"
                        if [[ "$TUI_TOOL" == "gum" ]]; then
                            summary=$(gum input --placeholder "Enter summary..." || echo "")
                            if [[ -z "$summary" ]]; then
                                summary="Manual summary"
                                log_info "Using default summary"
                            fi
                        else
                            summary=$(show_dialog "inputbox" "Manual Summary" "Enter a summary for this note:" 10 60 || echo "")
                            if [[ -z "$summary" ]]; then
                                summary="Manual summary"
                            fi
                        fi
                    else
                        summary="Manual summary"
                    fi
                fi
            fi
            ;;
        "Enter manual summary"|"2")
            if [[ -t 0 && -t 1 ]]; then
                echo "Enter a summary for this note:"
                if [[ "$TUI_TOOL" == "gum" ]]; then
                    summary=$(gum input --placeholder "Enter summary..." || echo "")
                    if [[ -z "$summary" ]]; then
                        summary="Manual summary"
                        log_info "Using default summary"
                    fi
                else
                    summary=$(show_dialog "inputbox" "Manual Summary" "Enter a summary for this note:" 10 60 || echo "")
                    if [[ -z "$summary" ]]; then
                        summary="Manual summary"
                    fi
                fi
            else
                summary="Manual summary"
            fi
            ;;
        "Skip summary"|"3"|*)
            summary="No summary provided"
            ;;
    esac

    # Tag management
    local tags=""
    if [[ -t 0 && -t 1 ]]; then
        echo "Would you like to add tags to this note?"
        if [[ "$TUI_TOOL" == "gum" ]]; then
            if gum confirm "Add tags to this note?" || true; then
                echo "Enter tags separated by commas (e.g., research, important, work):"
                tags=$(gum input --placeholder "research, important, work..." || echo "")
                if [[ -z "$tags" ]]; then
                    log_info "No tags entered"
                fi
            fi
        else
            if show_dialog "yesno" "Add Tags" "Would you like to add tags to this note?" 8 50; then
                tags=$(show_dialog "inputbox" "Tags" "Enter tags separated by commas (e.g., research, important, work):" 10 60 || echo "")
                if [[ -z "$tags" ]]; then
                    log_info "No tags entered"
                fi
            fi
        fi
    fi

    # Create the .norg file
    log_info "Creating .norg file..."
    local filepath=$(create_norg_file "$title" "$clipboard_content" "$summary" "$tags" "$original_url")

    if [[ -f "$filepath" ]]; then
        log_success "Created note: $filepath"
        if [[ "$TUI_TOOL" == "gum" ]]; then
            gum style --foreground 212 --border-foreground 212 --border double --align center --width 60 --margin "1 2" --padding "2 4" \
                "✅ Success!" \
                "" \
                "Note created successfully:" \
                "$filepath" \
                "" \
                "Title: $title" \
                "Tags: ${tags:-none}"
        else
            show_dialog "msgbox" "Success" "Note created successfully:\n\n$filepath\n\nTitle: $title\nTags: ${tags:-none}"
        fi

        # Ask if user wants to open the file
        if command -v $EDITOR >/dev/null 2>&1 && [[ -t 0 && -t 1 ]]; then
            echo "Would you like to open the file in your editor?"
            local should_open=false
            if [[ "$TUI_TOOL" == "gum" ]]; then
                if gum confirm || true; then
                    should_open=true
                fi
            else
                if show_dialog "yesno" "Open File" "Would you like to open the file in your editor?" 8 50; then
                    should_open=true
                fi
            fi

            if [[ "$should_open" == "true" ]]; then
                $EDITOR "$filepath" &
            fi
        fi
    else
        log_error "Failed to create note file"
        if [[ "$TUI_TOOL" == "gum" ]]; then
            gum style --foreground 196 "❌ Error: Failed to create the note file. Please check permissions and try again."
        else
            show_dialog "msgbox" "Error" "Failed to create the note file. Please check permissions and try again."
        fi
        exit 1
    fi
}

# Setup function for first-time configuration
setup() {
    show_dialog "msgbox" "Welcome" "Welcome to $SCRIPT_NAME!\n\nLet's configure your preferences."

    # Set output directory
    local new_output_dir=$(show_dialog "inputbox" "Output Directory" "Enter the directory where notes should be saved:" 10 60 "$OUTPUT_DIR")
    if [[ -n "$new_output_dir" ]]; then
        OUTPUT_DIR="$new_output_dir"
    fi

    # Set OpenAI API key (optional)
    if show_dialog "yesno" "AI Summarization" "Would you like to configure OpenAI API for AI-powered summarization?" 8 60; then
        local api_key=$(show_dialog "inputbox" "OpenAI API Key" "Enter your OpenAI API key (will be stored in $CONFIG_FILE):" 10 60)
        if [[ -n "$api_key" ]]; then
            OPENAI_API_KEY="$api_key"
        fi
    fi

    # Save configuration
    save_config
    log_success "Configuration saved to $CONFIG_FILE"

    show_dialog "msgbox" "Setup Complete" "Setup complete!\n\nOutput directory: $OUTPUT_DIR\nAI summarization: $([ -n "$OPENAI_API_KEY" ] && echo "Enabled" || echo "Disabled")\n\nYou can run this script again to create notes from clipboard content."
}

# Help function
show_help() {
    cat << EOF
$SCRIPT_NAME v$VERSION

DESCRIPTION:
    Create .norg files from clipboard content with TUI interface.
    Supports URL detection, AI summarization, and tag management.

USAGE:
    $0 [OPTIONS]

OPTIONS:
    -h, --help      Show this help message
    -s, --setup     Run first-time setup
    -v, --version   Show version information
    --config        Show current configuration

FEATURES:
    • Multi-platform clipboard support (xclip, wl-clipboard, pbcopy, clip)
    • Clean TUI interface using whiptail or dialog
    • Automatic URL title extraction
    • AI-powered summarization (OpenAI API)
    • Manual summary entry
    • Tag management
    • Proper .norg file format with metadata
    • Date-based filename generation

REQUIREMENTS:
    • gum, whiptail, or dialog (for TUI)
    • One of: xclip, wl-clipboard, pbcopy, or clip (for clipboard)
    • curl (for URL title extraction and AI summarization)
    • OpenAI API key (optional, for AI summarization)

INSTALLATION:
    # Install gum (recommended TUI tool)
    # On macOS:
    brew install gum

    # On Linux:
    # Debian/Ubuntu: sudo apt install gum
    # Arch: sudo pacman -S gum
    # Or download from: https://github.com/charmbracelet/gum

CONFIGURATION:
    Configuration is stored in: $CONFIG_FILE

    You can edit this file directly or run: $0 --setup

EXAMPLES:
    # Copy a URL to clipboard, then run:
    $0

    # First-time setup:
    $0 --setup

    # Show current configuration:
    $0 --config

EOF
}

# Show current configuration
show_config() {
    cat << EOF
Current Configuration:
=====================

Output Directory: $OUTPUT_DIR
Config File: $CONFIG_FILE
OpenAI API Key: $([ -n "$OPENAI_API_KEY" ] && echo "Configured" || echo "Not configured")

Detected Tools:
===============
EOF

    detect_clipboard_tool 2>/dev/null
    detect_tui_tool 2>/dev/null

    echo "Clipboard Tool: $CLIPBOARD_TOOL"
    echo "TUI Tool: $TUI_TOOL"
    echo "curl: $(command -v curl >/dev/null 2>&1 && echo "Available" || echo "Not available")"
    echo "Editor: ${EDITOR:-Not set}"
}

# Parse command line arguments
parse_args() {
    while [[ $# -gt 0 ]]; do
        case $1 in
            -h|--help)
                show_help
                exit 0
                ;;
            -s|--setup)
                setup
                exit 0
                ;;
            -v|--version)
                echo "$SCRIPT_NAME v$VERSION"
                exit 0
                ;;
            --config)
                show_config
                exit 0
                ;;
            *)
                log_error "Unknown option: $1"
                echo "Use --help for usage information."
                exit 1
                ;;
        esac
        shift
    done
}

# Cleanup function
cleanup() {
    # Only clear screen in interactive mode
    if [[ -t 0 && -t 1 ]]; then
        clear 2>/dev/null || true
    fi
}

# Signal handlers
trap cleanup EXIT

# Main execution
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
    parse_args "$@"
    main
fi
